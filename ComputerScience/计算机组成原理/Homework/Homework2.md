### 2.7

```assembly
slli x28, x28, 3 	 # x28 = i * 8
add x10, x10, x28  	# x10 = &A[i]
ld x28, 0(x10)  	# x28 = A[i]
slli x29, x29, 3  	# x29 = j * 8
add x12, x11, x29  	# x12 = &B[j]
ld x29, 0(x12)  	# x29 = B[j]
add x29, x28, x29  	# x29 = A[i] + B[j]
sd x29, 64(x11)  	# B[8] = A[i] + B[j]
```

### 2.8

```c
f = 2* &A;
```

### 2.9

|                  | type   | opcode, funct3,7 | rs1  | rs2  | rd   | imm  |
| ---------------- | ------ | ---------------- | ---- | ---- | ---- | ---- |
| addi x30,x10,8   | l-type | 0x13,0x0,-       | 10   | -    | 30   | 8    |
| addi x31,x10,0   | R-type | 0x13,0x0,-       | 10   | -    | 31   | 0    |
| sd x31,0(x30)    | S-type | 0x23,0x3,-       | 31   | 30   | -    | 0    |
| ld x30,0(x30)    | l-type | 0x3,0x3,-        | 30   | -    | 30   | 0    |
| add x5, x30, x31 | R-type | 0x33,0x0,0x0     | 30   | 31   | 5    | -    |

### 2.10

2.10.1 0x5000000000000000 

2.10.2 overflow 

2.10.3 0xB000000000000000 

2.10.4 no overflow 

2.10.5 0xD000000000000000 

2.10.6 overflow

### 2.22

2.22.1 [0x1ff00000, 0x200FFFFE] 

2.22.2 [0x1FFFF000, 0x20000ffe]

### 2.23

2.23.1 使用“UJ”指令格式可能是最合适的，因为它可以为循环参数提供尽可能多的位数

2.23.2 这可以通过三条指令来实现：

```assembly
addi x29, x29, -1  # 从x29中减去1
bgt x29, x0, loop  # 如果x29不是负数，则继续循环
addi x29, x29, 1   # 将不应该减去的1加回到x29
```

### 2.24

2.24.1 寄存器x5的最终值是20。

2.24.2 初始化累加器acc为0，设置计数器i为10。然后执行以下循环：
```c
while (i != 0) {
    acc += 2;
    i--;
}
```
在这段代码中，只要i不等于0，就将累加器acc增加2，并将计数器i减1。

2.24.3 需要`4*N + 1`条指令。

2.24.4 
初始化累加器acc为0，设置计数器i为10。然后执行以下循环：

```c
while (i >= 0) {
    acc += 2;
    i--;
}
```
在这段代码中，只要i大于等于0，就将累加器acc增加2，并将计数器i减1。这意味着循环将包括i为0的情况，直到i减到-1循环才会结束。

### 2.29

```assembly
fib:
    beq x10, x0, done 	# 如果n==0, 返回0
    addi x5, x0, 1
    beq x10, x5, done 	# 如果n==1, 返回1
    addi x2, x2, -16 	# 分配2个word的栈空间
    sd x1, 0(x2) 	# 保存返回地址
    sd x10, 8(x2) 	# 保存当前n
    addi x10, x10, -1 	# x10 = n-1
    jal x1, fib 	# 调用fib(n-1)
    ld x5, 8(x2) 	# 从栈中加载旧的n值
    sd x10, 8(x2) 	# 将fib(n-1)推入栈中
    addi x10, x5, -2 	# x10 = n-2
    jal x1, fib 	# 调用fib(n-2)
    ld x5, 8(x2) 	# x5 = fib(n-1)
    add x10, x10, x5 	# x10 = fib(n-1) + fib(n-2)
# 清理:
	ld x1, 0(x2) 	# 加载保存的返回地址
	addi x2, x2, 16 	# 从栈中弹出两个word
done:
	jalr x0, x1
```

### 2.30

下面是每次函数调用后栈的内容：

初始调用 `fib(n)`

- 栈指针：`0x7ffffffc`
- 栈内容：
  ```
  0x7ffffffc: 返回地址（jal指令的下一条指令地址）
  0x7ffffff0: 当前的n值
  ```

第一次递归调用 `fib(n-1)`

- 栈指针：`0x7fffefa8`（向下移动了16字节）
- 栈内容：
  ```
  0x7fffefa8: 返回地址（jal指令的下一条指令地址）
  0x7fffefa0: 当前的n值（n-1）
  0x7fffef98: 返回地址（fib函数的返回地址）
  0x7fffef90: 当前的n值（n）
  ```

第二次递归调用 `fib(n-2)`

- 栈指针：`0x7fffef40`（再向下移动了16字节）
- 栈内容：
  ```
  0x7fffef40: 返回地址（jal指令的下一条指令地址）
  0x7fffef38: 当前的n值（n-2）
  0x7fffef30: 返回地址（fib(n-1)的返回地址）
  0x7fffef28: 当前的n值（n-1）
  0x7fffef20: 返回地址（fib函数的返回地址）
  0x7fffef18: 当前的n值（n）
  ```

在每次递归调用结束后，函数会从栈中恢复返回地址和`n`值，然后栈指针会向上移动16字节，直到最终返回到最初的调用者。

