### 2.5.1 对大立即数的 RISC-V 编址和寻址

#### 2.5.1.1 大立即数

取立即数高位 `lui`，用于将 20 位常数加载到寄存器的 31 位到 12 位，最右边的 12 位完全用 0 填充

```assembly
# 目标：将一个32位常量加载到寄存器x19
# 常量举例（00000000 00111101 00000101 00000000）
lui x19， 976   
# 先使用lui加载高位，976的2进制为0000 0000 0011 1101 0000
# 此时x19寄存器后12为均为0
addi x19, x19, 1280  # 添加低位，1280二进制为00000101 00000000
```

#### 2.5.1.2 分支中的寻址

RISC-V 分支指令使用带有 12 位立即数的 RISC-V 指令格式（表示分支地址-4096~4094）

程序计数器 (`PC`) = 寄存器内容 + 分支地址偏移量

这样允许程序大到 2^32^并且能够继续使用条件分支指令，解决了分支地址大小问题

使用程序计数器作为寄存器，在距离当前指令的±2^10^个字的地方分支，或跳转到距离当前指令±2^18^个字的地方。因为所有循环和 if 语句都小于 2^10^个字，这种寻址方式被称为**PC 相对寻址**

RISC-V 允许使用双指令序列来非常长距离地跳转到任何 32 位地址: `lui` 将地址的第 12 位至第 31 位写人临时寄存器，`jalr` 将地址的低 12 位加到临时寄存器并跳转到目标位置。

大多数条件分支到达附近的位置，但偶尔会转移到很远的位置，超过条件分支指令中的 12 位地址能表示的范围。解决方法: 插入无条件跳转到分支目标，并将条件取反，以便条件分支决定是否跳过该无条件跳转。

```assembly
# 例题:远距离分支
# 寄存器x10等于0时给定一个分支
    beq x10，x0，L1	# 用一对提供更大分支距离的指令替换它
# 答案:用下面的指令替换短地址条件分支指令:
    bne x10，x0，L2
    ja1 x0，L1
L2:
```
#### 2.5.1.3 寻址模式总结

多种不同的寻址形式称为寻址模式，RISC-V 指令的寻址模式如下：
操作数以灰色阴影表示：
1. 立即数寻址，操作数是指令本身的常量
2. 寄存器寻址，操作数在寄存器中。
3. 基址或偏移寻址，操作数在内存中，其地址是寄存器和指令中的常量之和。
4. PC 相对寻址，分支地址是 PC 和指令中常量之和。
![[../../Picture/image-20241022112208324.png]]

#### 2.5.1.4 机器语言译码
在汇编语言和机器语言中进行手动翻译的表：
![[../../Picture/image-20241022112513668.png]]
![[../../Picture/image-20241022140505043.png]]

### [[../../Contents/第二章 计算机指令|回到目录]]