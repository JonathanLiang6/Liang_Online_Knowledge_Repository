### 2.6.1 并发与同步

#### 2.6.1.1 概述

任务间相互独立时，并行执行更容易；但大多数情况下任务间需要写作，需要知道各自何时写入何时读出。因各个任务间需要同步，若不同步则存在**数据竞争**的危险 

同步操作：**加锁**和**解锁**，可直接用于创建只有单个处理器可操作的区域，称为互斥区，可实现更复杂的同步机制

多处理器实现同步的关键：一组硬件原语，提供以**原子**方式读取和修改内存单元的能力（读取和写入之间无其他操作）

**原子交换**：原子交换是一种同步机制的基本操作，可以将寄存器中的值与存储器中的值进行交换。

**用途**：用于构建基本同步原语，如**锁变量**。

**锁变量**：值 `0` 表示锁可用。值 `1` 表示锁已被占用。
1. 处理器尝试通过将寄存器中的 `1` 与锁变量对应的内存地址的值进行交换来加锁。
2. 如果其他处理器已占用该锁，交换指令的返回值为 `1`，表示锁被占用。
3. 如果锁可用，返回值为 `0`，表示加锁成功，并将锁变量的值设置为 `1`。
**lock 的 C实现**
```C
// Lock的C语言实现
void lock（lock_t *lock） {
	while（LoadLinked（&lock -> flag）||
		！StoreConditional（&lock -> flag，1））;
		// 转换
}
```
**lock 的汇编实现**  ^c050f0
```arm-asm
Example 2: 
    addi x12, x0, 1          // 复制锁定值
again
    lr.d x10, (x20)         // 读取锁定值
    bne x10, x0, again      // 如果x10不为0，则跳转到again（检查是否为0）
    sc.d x11, (x20), x12    // 尝试存储
    bne x11, x0, again      // 如果失败，则跳转到again
Unlock:	// 解锁
    sw x0, 0(x20)           // 释放锁
```
---
**竞争条件**

当两个处理器同时尝试进行交换操作时：其中一个处理器会首先成功交换并返回 `0`。另一个处理器会返回 `1`，因为锁已被占用。

**原子性**：
交换操作是不可分割的，硬件将对同时发生的交换进行排序。
两个处理器不可能同时认为它们成功设置了锁变量。

---
#### 2.6.1.2 指令对

**指令对**：由两条指令组成，第二条指令返回一个值，表示该指令对是否被原子执行。

**原子执行**：如果所有其他操作都在指令对之前或之后执行，则该指令对实际上是原子的。

**结果**：在指令对之间，没有其他处理器可以改变值，从而确保了原子性。

指令对指的是下面这对指令：
- **保留加载 (Load-Reserved)**：用于加载内存中的值并标记该内存位置为“保留”。
- **条件存储 (Store-Conditional)**：用于尝试将值存储到内存中，并根据保留加载的状态判断是否成功。

**指令工作机制**
1. 顺序执行：首先执行保留加载指令。然后执行条件存储指令。
   
2. 成功与失败：如果在条件存储指令执行之前，保留加载指令指定的内存位置的内容发生了变化，则条件存储指令失败，不会将值写入内存。
   - 如果成功，条件存储指令将另一个寄存器的值更改为 `0`。
   - 如果失败，寄存器的值将被更改为非零值。

**寄存器配置：**`sc. W` 指令需要三个寄存器：
一个用于保存地址。一个用于指示原子操作的成功或失败。一个用于存储成功时的值。

**原子交换实现示例**
```arm-asm
# 以下序列在寄存器x20指向的内存位置上实现原子交换：
again: 
    lr.w x10, (x20)      	# 加载保留值
    sc.w x11, x23, (x20) 	# 条件存储
    bne x11, x0, again   	# 如果存储失败则跳转到 again
    addi x23, x10, 0    	# 将加载的值放入 x23
# 每当处理器在lr.w和sc.w指令之间修改内存中的值时，sc.w将非零值写入x11，导致代码序列重新执行。
# 序列结束时，x23的值和x20指向的内存位置的值发生了原子交换。
```

#### 2.6.1.3 条件存储的注意事项
在使用条件存储指令 (`sc. W`) 时，需要特别注意以下几点：

1. **指令插入的选择**：
在 `lr. W`（加载保留）和 `sc. W`（条件存储）之间插入的指令必须谨慎选择。
只有整点算术、前向分支和后向分支是允许执行的，这样可以避免潜在的问题。

2. **死锁风险**：
 如果在这两个指令之间插入了不当的指令，可能会导致死锁。例如，重复的页错误可能会使处理器永远无法完成 `sc. W` 操作。

3. **指令数量**：
保留加载和条件存储之间的指令数量应尽量减少，以降低由于不相关事件或竞争处理器导致条件存储频繁失败的可能性。

锁变量的获取与释放：尽管之前的代码实现了原子交换，但以下代码更有效地获取寄存器 `x20` 对应存储中的锁变量：[[#^c050f0|lock的汇编实现]]
锁变量的状态：0 表示锁变量是空闲的。1 表示锁变量被占用。
#### 2.6.1.4 同步在单处理器中的重要性
虽然同步机制最初是为多处理器环境设计的，但在单个处理器操作系统中处理多个进程时，原子交换同样重要。

**上下文切换**：如果处理器在两个指令对之间进行上下文切换，则条件存储可能会失败，从而保证了执行的原子性。

---

### 2.6.2 翻译并启动程序
将 C 程序从非易失性存储（如磁盘或闪存）转换为计算机上可运行程序的四个步骤：
1. **编译**：使用编译器将 C 程序（高级语言程序）转换成汇编语言程序。
2. **汇编**：使用汇编器将汇编语言程序转换成目标模块，即机器语言模块。
3. **链接**：使用链接器将多个目标模块与库程序组合在一起，以解析所有的引用，生成可执行代码。
4. **加载**：使用加载器将机器代码放入适当的存储器位置，以便处理器执行。

这些步骤可以被跳过或组合以加快转换过程。例如，一些编译器可以直接生成目标模块，而一些系统使用链接加载器来执行最后两个步骤
#### 2.6.2.1 编译器
**编译器**将单个源代码文件翻译成单个机器指令文件：称为**目标模块**

**目标模块**提供了从各个部分构建完整程序的信息：
- **头部**：描述了对象模块的内容
- **文本段**：翻译后的指令
- **静态数据段**：在程序生命周期内分配的数据
- **重定位信息**：与加载程序的绝对位置相关的内容
- **符号表**：全局定义和外部引用
- **调试信息**：用于与源代码关联的信息
#### 2.6.2.2 汇编器
汇编语言是高层软件的接口，因此汇编器可以处理机器指令的常见变体，硬件不需要实现这些指令，他们在汇编语言中的出现简化了程序转换和编程，称为伪指令

#### 2.6.2.3 链接器
将独立汇编的机器语言程序缝合在一起：
1. 将代码和数据模块按符号特征放入内存
2. 确定数据和指令标签的地址
3. 修补内部和外部引用

可以留给重定位加载器来解决位置依赖性，但有了虚拟内存，就不需要这样做了。程序可以被加载到虚拟内存空间中的绝对位置。

#### 2.6.2.4 加载器
从磁盘上的可执行文件加载到内存中：
1. 读取可执行文件头部以确定段大小
2. 创建虚拟地址空间
3. 将文本和初始化数据复制到内存中：或设置页表条目，以便它们可以在出现故障时被加载
4. 将主程序参数复制到栈顶
5. 初始化寄存器（包括 sp, fp, gp），并将栈指针指向第一个空闲位置
6. 跳转到启动例程，将参数复制到参数寄存器中并调用程序的主例程（`main`）：将参数复制到 x10, …并调用 main。当 main 返回时，执行 exit 系统调用。

#### 2.6.2.5 链接

**静态链接：**
生成一个可执行的镜像文件，合并多个模块中同名的 segments，解析外部符号，修改依赖外部符号的指令/数据信息


静态链接方法在程序运行之前将库文件链接到可执行代码中，虽然这种方法速度较快，但存在以下缺点：
1. **版本问题**：库例程成为可执行代码的一部分，如果库有新版本发布（如修复错误或支持新硬件），静态链接程序仍会使用旧版本。
2. **资源浪费**：静态链接会加载所有可能被调用的库例程，即使有些例程并未使用。例如，Linux 系统的标准 C 库大小约为 1.5 MiB。

**动态链接库（DLL）：**

为了解决静态链接的缺点，提出了动态链接库。动态链接库在程序运行时才链接和加载库例程，程序和库例程之间通过额外信息进行链接

**延迟过程链接**：

最初的 DLL 版本在加载时仍会链接所有可能被调用的库例程，而非仅链接实际调用的例程。为了解决这一问题，发展出了**延迟过程链接**的版本：每个例程仅在被调用时才进行链接。该技术依赖于间接跳转机制。

**工作机制：**

1. 第一次调用：程序通过虚入口执行间接跳转，指向一段代码，该代码识别所需的库例程并调用动态链接器/加载器。
2. 链接过程：链接器/加载器找到所需的例程，重新映射地址，并更新间接跳转位置。
3. 后续调用：之后的调用直接通过间接跳转访问该例程，无需重复链接过程。

**优点：** 仅在调用库过程时才链接/加载它，需要过程代码可重新定位，避免了由静态链接所有（递归）引用库引起的映像膨胀，并能自动获取新版本的库。

**延迟过程链接补充：**

- 间接表
- 存根：加载例程 ID，跳转到链接器/加载器
- 链接器/加载器代码；动态映射的代码

---

### 2.6.3 编程示例：排序

#### 2.6.3.1 排序

交换过程（叶程序）
```c
void swap(long long int v[ ], long long int k) {
    long long int temp;
    temp = v[k];
    v[k] = v[k + 1];
    v[k + 1] = temp;
}
```

交换过程（汇编）
```arm-asm
# v在x10中，k在x11中，temp在x5中
swap:
  slli x6, x11, 3      # reg x6 = k * 8
  add x6, x10, x6      # reg x6 = v + (k * 8)
  ld x5, 0(x6)         # reg x5 (temp) = v[k]
  ld x7, 8(x6)         # reg x7 = v[k + 1]
  sd x7, 0(x6)         # v[k] = reg x7
  sd x5, 8(x6)         # v[k + 1] = reg x5 (temp)
  jalr x0, 0(x1)       # return to calling routine
```
#### 2.6.3.2 C 中的排序过程
以冒泡排序为例，调用 swap
```c
void sort(long long int v[], long long int n) {
    long long int i, j;
    for (i = 0; i < n; i += 1) {
        for (j = i - 1; j >= 0 && v[j] > v[j + 1]; j -= 1) {
            swap(v, j);
        }
    }
}

```arm-asm
# v在x10中，n在x11中，i在x19中，j在x20中
# 保存寄存器:为5个寄存器在栈上分配空间
sort: 
 	addi sp, sp, -20 # 分配20字节的栈空间
    sw x1, 16(sp)    # 保存返回地址到栈
    sw x2, 12(sp)    # 保存x2寄存器到栈
    sw x21, 8(sp)    # 保存x21寄存器到栈
    sw x20, 4(sp)    # 保存x20寄存器到栈
    sw x19, 0(sp)    # 保存x19寄存器到栈
       
# 过程体
# 移动参数
    addi x21, x10, 0  # 将参数x10复制到x21
    addi x22, x11, 0  # 将参数x11复制到x22   
# 外循环
	addi x19, x0, 0    # 初始化i为0
for1tst: 
	bge x19, x22, exit1 # 如果i >= n，跳转到exit1
	addi x19, x19, 1  # i++
	
# 内循环
	addi x20, x19, -1  # 初始化j为i-1
for2tst: 
    blt x20, x0, exit2 # 如果j < 0，跳转到exit2
    slli x5, x20, 2    # x5 = j * 4
    add x5, x21, x5    # x5 = v + (j * 4)
    lw x6, 0(x5)       # x6 = v[j]
    lw x7, 4(x5)       # x7 = v[j+1]
# 参数传递和调用
    addi x10, x21, 0   # 第一个交换参数是v
    addi x11, x20, 0   # 第二个交换参数是j
    jal x1, swap       # 调用swap过程
        
# 内循环继续
    addi x20, x20, -1  # j--
    jal x0, for2tst    # 跳转回for2tst
# 外循环继续
exit2: 
    addi x19, x19, 1  # i++
    jal x0, forltst         # 跳转回forltst

# 恢复寄存器
exit1: 
	lw x19, 0(sp)  # 从栈恢复x19
    lw x20, 4(sp) # 从栈恢复x20
    lw x21, 8(sp) # 从栈恢复x21
    lw x22, 12(sp)# 从栈恢复x22
    lw x1, 16(sp) # 从栈恢复返回地址
    addi sp, sp, 20 # 恢复栈指针
# 过程返回
	jalr x0, 0(x1) # 返回到调用过程
```

经验教训：
- 指令计数和 CPI 不是孤立的性能指标
- 编译器优化对算法敏感

#### 2.6.3.3 数组与指针

- 数组索引涉及：将索引乘以元素大小加到数组基地址上
- 指针直接对应于内存地址, 可以避免索引复杂性
```c
// clear1函数：通过数组索引来将数组元素清零
void clear1(int array[], int size) {
    int i; // 定义循环变量i
    for (i = 0; i < size; i += 1) // 循环，直到i等于size
        array[i] = 0; // 将数组的第i个元素设置为0
}

// clear2函数：通过指针来将数组元素清零
void clear2(int *array, int size) {
    int *p; // 定义指针p
    for (p = &array[0]; p < &array[size]; p = p + 1) // 循环，直到p指向array[size]的地址
        *p = 0; // 将指针p指向的内存位置的值设置为0
}
```

```arm-asm
# 使用RISC-V汇编语言实现的数组清零操作
# 初始化循环变量i为0
li x5, 0

loop1:
    # 计算数组元素的地址
    slli x6, x5, 3  # x6 = i * 8 (将i左移3位，相当于乘以8)
    add x7, x10, x6 # x7 = address of array[i] (x10是数组的起始地址)
    # 将数组元素设置为0
    sd x0, 0(x7)    # array[i] = 0
    # i自增1
    addi x5, x5, 1  # i = i + 1
    # 如果i小于size，则跳转到loop1继续循环
    blt x5, x11, loop1 # if (i < size) go to loop1

# 将指针p初始化为数组起始地址
mv x5, x10

loop2:
    # 计算数组结束地址
    slli x6, x11, 3  # x6 = size * 8
    add x7, x10, x6  # x7 = address of array[size]
    # 将指针p指向的内存位置的值设置为0
    sd x0, 0(x5)     # Memory[p] = 0
    # p自增8（因为sd指令操作的是64位数据）
    addi x5, x5, 8   # p = p + 8
    # 如果p小于数组结束地址，则跳转到loop2继续循环
    bltu x5, x7, loop2 # if (p < &array[size]) go to loop2
```

### 2.6.4 数组相关

#### 清空数组示例
```c
clear1(int array[], int size) {
    int i;
    for (i = 0; i < size; i += 1)
        array[i] = 0;
}

clear2(int *array, int size) {
    int *p;
    for (p = &array[0]; p < &array[size]; p = p + 1)
        *p = 0;
}
```

#### 数组与指针的比较
- 乘法“强度降低”为位移
- 数组版本需要在循环内进行位移
- 是递增 i 的索引计算的一部分
- 与递增指针相比
- 编译器可以实现与手动使用指针相同的效果
- 归纳变量消除
- 更好的做法是使程序更清晰、更安全

### [[../../Contents/第二章 计算机指令|回到目录]]