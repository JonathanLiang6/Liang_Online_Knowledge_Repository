### 2.2.1 硬件设计

#### 2.2.1.1 计算机硬件设计基本原则：

**1. 简单源于规整**

规律性使得实现更加简单，简单性可以更低的成本实现性能

**2. 更少则更快**

数量更多的寄存器会增加时钟周期，但该设计原则不是绝对的；设计人员需要在程序对更多寄存器的需求和设计人员对缩短时钟周期的期望之间取得平衡。

**3. 优秀设计需要适当的折中**（见下 2.3.2.2）

RISC-V 设计人员选择的折中方案是保持所有指令长度相同，对于不同的指令使用不同的指令格式。例如，上面的格式称为 R 型 (用于寄存器)。另一种指令格式的类型是 1 型，用于带一个常数的算术指令 (例如 addi) 以及加载指令。I 型的字段如下所示:

#### 2.2.1.2 算术操作

```assembly
# 举例：算术运算：a=b+c+d+e
add a, b, c 	# b+c存入a
add a, a, d 	# 结果+d存入a
add a, a, e 	# 结果+e存入a
```

> 硬件简单的设计逻辑：操作数数量可变的硬件比固定数量的硬件更复杂

每个算术指令只执行一个操作且必须仅有三个变量

### 2.2.2 计算机硬件的操作数

算术指令的操作数会受到限制：必须取自**寄存器**

寄存器数量有限且内建于硬件的特殊位置，大小分为 64 位（双字）和 32 位（字）

#### 2.2.2.1 寄存器介绍
![[../../Picture/image-20240920111044959.png]]
#### 2.2.2.2 存储器操作数

**数据传输指令:**  在内存与寄存器之间传输数据的指令

要访问内存中的字或者双字，指令必须提供内存**地址**

将数据从内存复制到寄存器的数据传输指令称为**载入指令**（load）（具体指令格式见章首表）

```assembly
ld x9, 8(x22)	# 将基址寄存器（x22）偏移8位（一个字节）的数据存入临时寄存器（x9）中，
```

另：存放基础地址的寄存器称为**基址寄存器**，指令中寄存器前数字代表**偏移量**

#### 2.2.2.3 内存操作数

内存主要用于复合数据的存储，如数组，结构体，动态数据等（这几种数据类型因其所需内存过大一般不存储于寄存器中）

对算术运算使用的约定：

- 将值从内存加载到寄存器中
- 通过读/写寄存器中的数据来计算算术
- 从寄存器向内存存储数据

内存是**字节寻址**的，每一个地址占一个字节（8 位）

> **寄存器与内存对比**

寄存器访问速度与效率远快于内存

**原因:**  对内存数据操作时需要进行加载（load）与存储（store），而所需执行的指令越多，速度就越慢。

**结论:**  编译器（负责 C/C++变量映射到寄存器或内存的分配方案）必须尽可能多地为变量使用寄存器，仅对其中不常使用的变量溢出到内存进行存储

寄存器优化极为重要
#### 2.2.2.4 常数或立即数操作数
```assembly
# 根据现有的指令，常数需要被放入内存中取出使用
ld x9, address (x3)	# 对x9寄存器加载常数4（假设address是存储常数4的地址
add x22, x22, x9	# x22 += x9

# 避免使用加载指令的一种方法是使用另一种算术指令
addi x22, x22, 4		# 立即数加，表示x22 += 4，该操作经常出现，因其速度更快，能耗更低
addi x22, x22, -4		# 立即数减尽量使用加一个负数进行替换以增加效率

# 常数0，RISC-V中将寄存器x0硬连线到常数0（即不可覆写）
sub x9, x0, x8	# 可用于简化取相反数操作
```
#### 2.2.2.5 空指令

`No-Op` 是不进行任何操作的指令

用途：稍后可用于替换代码，空指令可填充空间，对齐数据，执行其他选项

```assembly
add x0 x0 x0	# RISC-V特定的无操作指令
```

#### 2.2.2.6 字节顺序

上文提到，**内存是字节为单位寻址的**，但操作数可能是多字节的，故对字节顺序有所差异

假设有一个 32 位的整数 `0x12345678`，在内存中的存储顺序如下：

**大端法:**  数据的最高有效字节存储在低地址

| 地址   | 值            |
| ---- | ------------ |
| 0x00 | 0x12  (最高字节) |
| 0x01 | 0x34         |
| 0x02 | 0x56         |
| 0x03 | 0x78  (最低字节) |

**小端法:**  数据的最低有效直接存储在低地址，RISC-V 使用的是小端法编址

| 地址   | 值            |
| ---- | ------------ |
| 0x00 | 0x78  (最低字节) |
| 0x01 | 0x56         |
| 0x02 | 0x34         |
| 0x03 | 0x12  (最高字节) |

（仅当以双字形式/八个单独字节访问相同数据时，字节顺序才有影响，因此大多数情况下无需考虑大小端）

### 2.2.3 有符号数与无符号数

#### 2.2.3.1 有符号数与无符号数的转换

**规则:** 位模式不变，但是解释这些位的方式改变了

**函数关系**：

1. 有符号数转化为无符号数

T2U$w$(x) = $\begin{cases}
	x + 2^w , x < 0 \\
	 \\
	x , x >= 0\\ 
\end{cases}$

2. 无符号数转化为有符号数

U2T$w$(y) = $\begin{cases}
	y , y <= TMax_w \\
	 \\
	y - 2^y , y > TMax_w\\ 
\end{cases}$​

**应用:** C 语言中，有符号数与无符号数运算时，有符号数会被隐式强制转换为无符号数

```c
int a = -1;
unsigned int b = 0;
if (a < b)
    printf("-1 < 0")
else 
    printf("-1 > 0")
// 运行结果：
// 		-1 > 0
```

因为上述提到的转换问题，此处的 `a < b` 实际上在比较 $2^{32}$ - 1 < 0 故输出 `-1 > 0`

#### 2.2.3.2 不同数据类型的转换

##### **较小的数据类型转换为较大的数据类型:** 可以保持数值不变

1. **无符号数:** 0 扩展

即将原数码置于后对应位，空位补零

| unsigned char      |     |     |     |     |     |     |     |     | $x_7$ | $x_6$ | $x_4$ | $x_3$ | $x_2$ | $x_1$ | $x_0$ |
| ------------------ | --- | --- | --- | --- | --- | --- | --- | --- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| **unsigned short** | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | $x_7$ | $x_6$ | $x_4$ | $x_3$ | $x_2$ | $x_1$ | $x_0$ |

2. **有符号数:** 符号位扩展

| char |      |      |      |      |      |      |      |      | $x_7$ | $x_6$ | $x_4$ | $x_3$ | $x_2$ | $x_1$ | $x_0$ |
| ------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **short ($x_7$=0)** | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | $x_7$ | $x_6$ | $x_4$ | $x_3$ | $x_2$ | $x_1$ | $x_0$ |
| **short ($x_7$=1)** | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | $x_7$ | $x_6$ | $x_4$ | $x_3$ | $x_2$ | $x_1$ | $x_0$ |

##### **较大的数据类型转换为较小的数据类型:** 被迫面临数据的改变

1. **无符号数:** 相当于取模

将一个 w 位数截断为 k 位，自动舍弃前 (w-k) 位

**e.g** 以十进制为例：123456 取低三位

$\Leftrightarrow$ ​ 123456 % $10^3$

可得：截断操作等价于 mod $2^k$

2.  **有符号数:** 分两步![[../../Picture/image-20240506162615188.png]]

Step_1：无符号数的截断

Step_2：无符号数转化为有符号数

### [[../../Contents/第二章 计算机指令|回到目录]]