### 2.4.1 基本知识

**过程或函数**是编程人员用于结构化编程的工具，两者均有助于提高程序的可理解性和代码的可重用性。

同样，在执行过程时，程序必须遵循以下六个步骤:
1. 将参数放在过程可以访问到的位置。
2. 将控制转交给过程。
3. 获取过程所需的存储资源。
4. 执行所需的任务。
5. 将结果值放在调用程序可以访问到的位置。
6. 将控制返回到初始点，因为过程可以从程序中的多个点调用。

如上所述，寄存器是计算机中访问数据最快的存储位置，因此期望尽可能多地使用它们。RISC-V 软件为过程调用分配寄存器时遵循以下约定:

- x10~x17：八个参数寄存器，用于传递参数或返回值
- x1：一个返回地址寄存器，用于返回到起始点

```assembly
# 仅用于过程的指令：jal
# 跳转到某个地址的同时将下一条指令的地址保存到目标寄存器rd
jal x1， Address		#跳转到Address，将返回地址写入x1
```

#### 2.4.1.2 使用更多寄存器的处理方式

如果需要使用≥8 个寄存器时，所有寄存器都必须恢复到调用之前存储的值

换出寄存器的理想数据结构是**栈**，**栈指针**是寄存器 `x 2` 也称为 `sp`

（数据压入栈中称为压栈，移除数据称为弹栈）

为避免保存和恢复一个其值从未被使用过的寄存器（通常为临时寄存器），RISC-V 将 19 个寄存器分成两组：

| 寄存器编号          | 功能    | 解释                         |
| -------------- | ----- | -------------------------- |
| x5\~x7，x28~x31 | 临时寄存器 | 在过程调用中不被调用者保存（被调用的过程不保存）   |
| x8\~x9，x18~x27 | 保存寄存器 | 在调用中必须被保存（一旦使用，由被调用者保存并恢复） |

### 2.4.2 嵌套过程
![[../../Picture/image-20241022092525819.png]]
不调用其他过程的过程称为**叶子过程**

过程可能会调用其他过程或者这个过程本身（递归调用）。因此要小心地使用寄存器。

**非叶子函数：** 调用其他函数的函数

**实现嵌套的函数调用：** 在调用前，在栈上保存: 返回地址（ra 寄存器的旧值）

调用之后仍然需要使用的：任何参数和临时值；在调用后，从栈上恢复这些值

解决方法：将所有必须保存的寄存器压栈：

调用者将调用后还需要的参数寄存器 `x10~17` 或临时寄存器压栈；被调用者将返回地址寄存器 `x1` 和被调用者使用的保存寄存器压栈。

调整栈指针 `sp` 以计算压栈寄存器的数量，返回时恢复寄存器并重新调整栈指针。

**举例如下：**

```C
int fact (int n)  {
    if (n < 1) 
        return 1; 
    else 
        return n * fact(n - 1);
}
```

```assembly
fact:
    addi sp, sp, -8        # 调整栈以保存两个项目
    sw x1, 4(sp)          # 保存返回地址
    sw x10, 0(sp)         # 保存参数 n

    addi x5, x10, -1       # x5 = n - 1
    bge x5, x0, L1        # 如果 (n - 1) >= 0，跳转到 L1

    # n < 1 的情况
    addi x10, x0, 1       # 返回 1
    addi sp, sp, 8        # 从栈中弹出两个值
    jalr x0, 0(x1)        # 返回到调用者

L1:
    addi x10, x10, -1     # n >= 1: 参数变为 (n - 1)
    jal x1, fact          # 调用 fact(n - 1)

    # 从 jal 返回
    addi x6, x10, 0       # 将 fact(n - 1) 的结果移动到 x6
    lw x10, 0(sp)         # 恢复参数 n
    lw x1, 4(sp)          # 恢复返回地址
    addi sp, sp, 8        # 调整栈指针以弹出两个项目

    mul x10, x10, x6      # 返回 n * fact(n - 1)
    jalr x0, 0(x1)        # 返回到调用者
```

**说明：**

- `x 3` / `gp` 一些 RISC-V 编译器保留了一个寄存器用于全局指针，用于简化静态数据的访问
- `sp` 以上的栈通过确保被调用者不在其上进行写入来保存，`sp` 本身由被调用者将其被减去的值重新加上来保存的，并且其他寄存器通过将他们保存到栈并从栈中将其恢复来进行保存
![[../../Picture/image-20241018152218481.png]]

### 2.4.3 为新数据分配空间

#### 2.4.3.1 在栈中为新数据分配空间

栈中包含过程所保存的寄存器和局部变量的段称为**过程帧/活动记录**
![[../../Picture/image-20241021095239950.png]]

帧指针（`fp` / `x 8`）指向帧的第一个字（通常为保存的参数寄存器），帧指针在过程中为局部变量引用提供一个稳定的基址寄存器

栈指针（`sp`）指向栈顶

#### 2.4.3.2 在堆中为新数据分配空间
![[../../Picture/image-20241021110848550.png]]
数组具有固定长度，可与静态数据段很好地匹配，存放数组/链表的段称为堆，它置于内存中。

这种分配允许栈和堆相向而长，从而随着这两个段的此消彼长达到内存的高效使用

**加速经常性事件的例子：** 使用多个寄存器而无须进入内存, 参数超过 8 个的情况：前八个位于 `x 10` 到 `x 17` 中，其余参数在内存中（帧指针寻址）
![[../../Picture/image-20241021111431125.png]]
帧指针的**方便性**在于对过程中栈内变量的所有引用具有相同的偏移
一些递归可以不使用递归而使用**迭代**，从而优化性能
例子如下：

```c
int sum (int n, int acc)  {
    if (n > 0) {
        return sum(n - 1, acc + n);
    } 
    else {
        return acc;
    }
}
```

```assembly
sum:  
    add x11, x11, x10  # 将x10寄存器的值（n）加到x11寄存器的值（acc）上
    addi x10, x10, -1  # 将x10寄存器的值减1，即n自减1
    jal x0, sum        # 跳转到sum函数，实现递归调用
sum_exit:  
    addi x12, x11, 0   # 将x11寄存器的值（当前acc）赋给x12寄存器，准备返回
    jalr x0, 0(x1)     # 返回到调用者，x1寄存器包含调用者的返回地址
```

---

### 附加：人机交互

![[../../Picture/image-20241021140401603.png]]
字节转移指令：
```assembly
# 复制一个字节从x10到x11
lbu x12, 0(x10)	#从内存加载一个字节
sb x12, 0(x11)	#从寄存器最右边8位取一个字节写入内存
```

字符串的表示：

1. 字符串的第一个位置保留，用于给出字符串长度
2. 附加带有字符串长度的变量
3. 字符串最后位置用一个字符标记字符串结尾（C 语言选择的方法，null）


RISC-V 指令系统支持加载和存储 16 位半字的指令。以下是两种相关的指令：

- 加载无符号半字 (`lhu`)**功能**：从内存中读取一个 16 位的半字，将其放置在寄存器的最右边 16 位，并将最左边的 16 位用零填充。

- 存储半字 (`sh`)**功能**：从寄存器的最右边 16 位取出半字，并将其写入内存。

```assembly
  lhu x19, 0(x10)  // 从内存地址x10处读取一个16位的半字，并将其存储在寄存器x19中
  sh x19, 0(x11)  // 将寄存器x19中的半字写入内存地址x11处
```

**注意**：加载半字指令（带有 `1 h` 后缀）将半字视为有符号数，并进行符号扩展以填充寄存器的最左边 16 位。

---

### [[../../Contents/第二章 计算机指令|回到目录]]