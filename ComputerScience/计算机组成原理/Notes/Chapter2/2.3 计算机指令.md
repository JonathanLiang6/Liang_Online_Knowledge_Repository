### 2.3.1 基本知识
一条指令的每一段称为一个**字段**
![[../../Picture/image-20241007155928072.png]]
![[../../Picture/image-20241007155948195.png]]
![[../../Picture/image-20241007155609229.png]]

指令的设计称为指令格式，RISC-V 指令只需要 32 位（一个字）；把指令的数字表示称为**机器语言**，这样的指令序列称为**机器码**，可以使用 16 进制代替 2 进制来简化存储：
![[../../Picture/image-20241007155824932.png]]

### 2.3.2 RISC-V 字段

#### 2.3.2.1 R 型（用于寄存器）指令

| funct 7 | rs 2 | rs 1 | funct 3 | rd  | opcode |
| ------- | ---- | ---- | ------- | --- | ------ |
| 7 位     | 5 位  | 5 位  | 3 位     | 5 位 | 7 位    |

以下是 RISC-V 指令中每个字段名称的含义

| 字段           | 含义                  |
| :----------- | ------------------- |
| opcode (操作码) | 指令的基本操作，这个缩写是它的惯用名称 |
| rd           | 目的操作数寄存器，用来存放操作结果   |
| funct 3      | 一个另外的操作码字段          |
| rs 1         | 第一个源操作数寄存器          |
| rs 2         | 第二个源操作数寄存器          |
| funct 7      | 一个另外的操作码字段          |

#### 2.3.2.2 I 型（用于带常数）指令

| immediate | rs 1  | funct 3 | rd   | opcode |
| --------- | ---- | ------ | ---- | ------ |
| 12 位      | 5 位  | 3 位    | 5 位  | 7 位    |

补充解释如下

| 条目           | 含义                                                                            |
| ------------ | ----------------------------------------------------------------------------- |
| 字段 immediate | 补码，表示$-2^{11}到 2^{11}-1$之间的整数，表示一个字节偏移量                                       |
| 指令 load      | 这是一个 i 型指令，在 load 指令中，12 位的立即数（`immediate`）先符号扩展，再跟寄存器 rs 1 中的基地址相加，得到最终的内存地址 |

#### 2.3.2.3 S 型指令

| immediate[11:5] | rs 2 | rs 1 | funct 3 | immediate[4:0] | opcode |
| --------------- | ---- | ---- | ------- | :------------- | ------ |
| 7 位             | 5 位  | 5 位  | 3 位     | 5 位            | 7 位    |

其中立即数 `immediate` 被分为两个部分为了保持 `rs2` 和 `rs1` 的位置不变

#### 2.3.2.4 指令补充
应尽量使得各种指令格式一致，对比如下：
![[../../Picture/image-20241011132817240.png]]

**寄存器问题：**

所有指令需要从寄存器中读取值进行操作

可以使用将所有 read 寄存器保持在同样位置 $\rightarrow$ CPU 可以无论任何指令直接读取寄存器

注：若读入的值是无效的（如 i 型指令中无需 rs 2），可以在后面阶段忽略该值

**操作码（`opcode`）：**

用于区分不同的指令格式，理论上需要最先解码，现在可以一边解码一边读取寄存器

即：解码 `opcode` 的同时将 24~15 位视为读寄存器开始读取

### 2.3.3 汇编指令到机器码的映射

汇编指令 $\Leftrightarrow$ 机器码：**一一映射**

**汇编：** 将汇编指令翻译为二进制机器码

**反汇编：** 将机器码转换为汇编指令

指令（程序代码）像数据一样，用二进制表示，存储在内存中，因此：

- 指令集相同的情况下可以直接下载二进制文件运行
- 程序可以用来处理另外的程序（例如：编译器，链接器）
- 指令也有内存地址：存于 PC 的寄存器（区别于 x 0-x 31）

### 2.3.4 逻辑运算

#### 2.3.4.1 位运算
用于访问宽度小于一个字的数据
![[../../Picture/image-20241011133855071.png]]

移位运算 `Shift Operations`：

| funct 6 | immed | rs 1 | funct 3 | rd  | opcode |
| ------- | ----- | ---- | ------- | --- | ------ |
| 6       | 6     | 5    | 3       | 5   | 7      |

Immed：表示移多少位

| 运算     | 操作        | 解释                                                             |
| :----- | :-------- | :------------------------------------------------------------- |
| （逻辑）左移 | 左移，右边补 0   | 左移 i 位 $\Leftrightarrow$ 乘 $2^i$（舍去小数）                              |
| （逻辑）右移 | 右移，左边补 0   | 右移 i 位 $\Leftrightarrow$ 除以 $2^i$（仅适用于无符号数）（舍去小数）                   |
| 算术右移   | 右移，左边补符号位 | 大部分情况：与逻辑右移相同，$\Leftrightarrow$ 除以 2 $^i$<br>进行算术右移的数为奇负数时不同，向下取整 |

按位与 `and`: 用作掩码，掩盖特定的位
按位或 `or`：引入一些位值到字中
按位异或 `xor`（相同为 0 不同为 1）：x 与 0 异或得 x；与 1 异或得 $\overline{x}$

#### 2.3.4.2 必要性
需要使用移位指令和逻辑运算指令读写字节 `word` 内部的位 `bit` 值

```c
int* packet;
packet[0] = src_port << 16 | dest_port
```
以上 C 语言对应的汇编代码
```assembly
slli x4, x2, x16
or x4, x4, x3
sw x4,0(x1)
```

### 2.3.5 条件运算

#### 2.3.5.1 if 运算
```assembly
# 如果条件成立，跳转到特殊标记的指令
# 否则，继续按顺序执行

beq rs1, rs2, L1	# if (rs1 == rs2) {L1}
bne rs1, rs2, L2	# if (rs1 != rs2) {L2}
```
以下进行举例
```c
// C code:
if (i == j) 
    f = g + h;
else 
    f = g - h;
```
```assembly
# 假设f，g，h分别在x19，x20，x21寄存器

# RISC-V code：
	bne x20, x21, Else          # 如果 x20 不等于 x21，则跳转到 Else 标签
	add x19, x20, x21           # 如果相等，执行加法：f = g + h（将 g 和 h 相加，结果存储到 x19）
	beq x0, x0, Exit            # 无条件跳转到 Exit 标签
Else: 
	sub x19, x20, x21      # Else：执行减法：f = g - h（将 g 和 h 相减，结果存储到 x19）
Exit: 
	…				# 后续操作
```

#### 2.3.5.2 while 循环
```c
// C code:
while (save[i] == k)
    i += 1; 
```
```assembly
# 假设i，k，save数组基址分别位于x22，x24，x25寄存器；save数组每个元素8字节

# RISC-V code：
Loop: 
	slli x10, x22, 3   #i*8-> x10      
	add  x10, x10, x25	# save + i*8, 即&(save[i])      
	ld   x9, 0(x10)	# 加载save[i]到x9寄存器      
	bne  x9, x24, Exit	# 比较x9和x24
    addi x22, x22, 1      
    beq  x0, x0, Loop   #实现了无条件转移
Exit: …
```

#### 2.3.5.3 case/switch 语句
编码形成指令序列的地址表，称为**分支地址表**或**分支表**，程序只需要索引到表中，然后跳转到合适的指令序列。

**分支表**只是一个字数组，其中包含与代码中的标签对应的地址。

该程序将分支表中的相应条目加载到寄存器中，然后需要使用寄存器中的地址进行跳转。

RISC-V 这类指令系统包含一个间接跳转指令（`jalr`），该指令对寄存器中指定的地址执行无条件跳转。

#### 2.3.5.4 补充知识
1. **基本块：** 一个基本块是一段连续的指令序列
内部没有跳转指令 (除了结尾)；内部没有跳转的目标标签 (除了开始) 8
编译器识别基本块以便优化，高级处理器能加速基本块的执行。

2. **更多条件运算**
有符号比较分支指令：blt，bge
```assembly
	blt rs1, rs2, L1	# if (rs1 < rs2) 跳转到标记为L1的指令
	bge rs1, rs2, L1	# if (rs1 >= rs2) 跳转到标记为L1的指令
	
# Example:	if (a > b) a += 1; 假设a in x22, b in x23
	bge  x23, x22, Exit       # branch if b >= a
	addi x22, x22, 1
Exit:
```
无符号比较分支指令：bltu，bgeu

### [[../../Contents/第二章 计算机指令|回到目录]]