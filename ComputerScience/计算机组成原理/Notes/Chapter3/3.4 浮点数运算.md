### 3.4.1 浮点数加法
#### 3.4.1.1 计算方法
**Step1：** 对齐小数点的位置：即对指数小的数进行移位
**Step2：** 对整数和小数部分分别进行相加
**Step3：** 规格化运算结果并检测有无溢出
**Step4：** 舍入，在有必要时进行再次规格化
#### 3.4.1.2 浮点加法器
比整数加法器复杂很多：过程冗长，难以在单个时钟周期内完成，远远长于整数加法的过程如果单个时钟周期，其他指令都会浪费时间：因此，浮点加法器通常多个时钟周期(可以流水化实现)
![](../../Picture/Pasted%20image%2020241114092911.png)
![](../../Picture/Pasted%20image%2020241114092936.png)
### 3.4.2 浮点乘法
#### 3.4.2.1 计算方法
**Step1：** 指数：直接进行相加（但应保证偏移值仅加了一个）
**Step2：** 有效数位部分进行相乘
**Step3：** 将乘积规格化
**Step4：** 舍入，在有必要时进行再次规格化
![](../../Picture/Pasted%20image%2020241114102659.png)
### 3.4.3 RISC-V 中的浮点指令
#### 3.4.3.1 浮点指令全集
RISC-V 支持 IEEE 754 标准的单精度和双精度浮点格式，提供了多种浮点运算指令，包括：
- 加法：`fadd.s`（单精度），`fadd.d`（双精度）
- 减法：`fsub.s`（单精度），`fsub.d`（双精度）
- 乘法：`fmul.s`（单精度），`fmul.d`（双精度）
- 除法：`fdiv.s`（单精度），`fdiv.d`（双精度）
- 平方根：`fsqrt.s`（单精度），`fsqrt.d`（双精度）
- 相等比较：`feq.s`（单精度），`feq.d`（双精度）
- 小于比较：`flt.s`（单精度），`flt.d`（双精度）
- 小于或等于比较：`fle.s`（单精度），`fle.d`（双精度）

比较指令 `feq`、`flt` 和 `fle` 会根据比较结果将整数寄存器设置为 0（假）或 1（真），从而允许使用整数分支指令 `beq` 和 `bne` 进行条件分支。

RISC-V 还提供了独立的浮点寄存器，编号为 `f0` 到 `f31`。这些寄存器有专门的加载和存储指令：
- 双精度：`fld`（加载），`fsd`（存储）
- 单精度：`flw`（加载），`fsw`（存储）

浮点数据传输指令使用整数寄存器作为基址寄存器。以下是一个 RISC-V 代码示例，展示了如何从内存中加载两个单精度浮点数，进行相加，并将结果存回内存：
```asm-arm
flw f0, 0(x10) // 将32位浮点数加载到f0
flw f1, 4(x10) // 将32位浮点数加载到f1
fadd.s f2, f0, f1 // 单精度加法，f2 = f0 + f1
fsw f2, 8(x10) // 将32位浮点数从f2存储到内存
```
注意，单精度寄存器是双精度寄存器的后半部分。浮点寄存器 `f0` 没有硬连接到常数 0，这与整数寄存器 `x0` 不同。

RISC-V 的浮点指令使用与整数指令相同的格式：
- 加载指令使用 I 型格式
- 存储指令使用 S 型格式
- 算术指令使用 R 型格式
#### 3.4.3.2 代码示例：矩阵乘法
```c
#include <x86intrin.h> // 包含x86平台的内在函数头文件

// 双精度矩阵乘法函数，使用AVX指令集加速
void dgemm(int n, double* A, double* B, double* C) {
    // 外层循环遍历矩阵C的行，步长为4，以便于使用AVX指令集处理
    for (int i = 0; i < n; i += 4) {
        // 中层循环遍历矩阵C的列
        for (int j = 0; j < n; j++) {
            // 使用AVX指令从矩阵C加载一个256位的双精度浮点数向量
            __m256d c0 = _mm256_load_pd(C + i + j * n); // c0 《= C[i][j]

            // 》内层循环计算矩阵A的第i行与矩阵B的第j列的点积
            for (int k = 0; k < n; k++) {
                // 加载矩阵A的第i行第k列的双精度浮点数到向量
                __m256d aik = _mm256_load_pd(A + i + k * n);
                // 将矩阵B的第k行第j列的双精度浮点数广播到向量的每个元素
                __m256d bkj = _mm256_broadcast_sd(B + k + j * n);
                // 计算向量aik和bkj的逐元素乘积
                __m256d prod = _mm256_mul_pd(aik, bkj);
                // 将乘积向量加到累加向量c0上
                c0 = _mm256_add_pd(c0, prod); // c0 += A[i][k] * B[k][j]
            }

            // 将累加后的向量c0存储回矩阵C的对应位置
            _mm256_store_pd(C + i + j * n, c0); // C[i][j] = c0
        }
    }
}
```
```arm-asm
vmovapd (%r11), %ymm0      # 将C的4个元素加载到%ymm0
mov %rbx, %rcx            # 寄存器%rcx = %rbx
xor %eax, %eax            # 寄存器%eax = 0
vbroadcastsd (%rax,%r8,1), %ymm1  # 制作B元素的4个副本
add $0x8, %rax            # 寄存器%rax = %rax + 8
vmulpd (%rcx), %ymm1, %ymm1  # 并行乘法%ymm1，8个A元素
add %r9, %rcx            # 寄存器%rcx = %rcx + %r9
cmp %r10, %rax           # 比较%r10和%rax
vaddpd %ymm1, %ymm0, %ymm0  # 并行加法%ymm1和%ymm0
jne 50 <dgemm+0x50>     # 如果%r10 != %rax，则跳转到dgemm+0x50
add $0x1, %esi           # 寄存器%esi = %esi + 1
vmovapd %ymm0, (%r11)    # 将%ymm0存储到4个C元素
```
### [[../../Contents/第三章 计算机的算术运算|回到目录]]