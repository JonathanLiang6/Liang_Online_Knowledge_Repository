### 3.2.1 无符号乘法
引入：一个 n 位的乘数与一个 m 位的乘数相乘最多得到一个 (n+m) 位的数值
二进制乘法中只使用 0 和 1，因此乘法规则为：
1. 如果乘数位为 1，只需将被乘数 (1x 被乘数) 复制到适当的位置。
2. 如果乘数位为 0，则将 0 (0x 被乘数) 置于适当的位置。

串行版乘法算法及硬件实现：
#### 3.2.1.1第一版乘法器：类似竖式运算
![image-20241175734646.png](/Picture/image-20241175734646.png)
![image-2024117149387.png](/Picture/image-2024117149387.png)
**被乘数：**
64 位被乘数寄存器初始化：右半部分 32 位被乘数，左半部分 32 位 0
每一步计算中，被乘数左移一位
#### 3.2.1.2 改良版乘法硬件
![](../../Picture/Pasted%20image%2020241114114420.png)
### 3.2.2 带符号乘法
**基本算法：** 将上述乘法算法迭代执行 31 次 (符号位不参与运算)，仅在两乘数符号相反时，对得到的结果取反
#### 3.2.2.1 快速乘法
![image-20241110162654.png](/Picture/image-20241110162654.png)
**并行加法方式优化乘法运算：**
在乘法运算开始时检查 32 个乘数位，判定是否加上被乘数 $\Rightarrow$ 为每个乘数位提供一个 32 位的加法器（$ 输入_1$ 为被乘数与上一个乘数位相与的结果；$输入_2$ 为上一个加法器的输出） 
上述设计可以 **流水化** 支持多个乘法
#### 3.2.2.2 RISC-V 中的乘法
为了得到正确的带符号或无符号的64位乘积，RISC-V提供了四条指令：
1. 要获得整数32位乘积，应使用`mul`指令。
2. 要得到64位乘积的高32位：
    - 如果两个操作数都是有符号的，应使用`mulh`指令。
    - 如果两个操作数都是无符号的，则使用`mulhu`指令。
    - 如果一个操作数是有符号的而另一个是无符号的，则使用`mulhsu`指令
### 3.2.3 整数除法
#### 3.2.3.1 无符号除法
![image-202411102648404.png](/Picture/image-202411102648404.png)
![image-20241111656350.png](/Picture/image-20241111656350.png)
#### 3.2.3.2 有符号除法
**基本算法：** 记录被除数和除数的符号，若符号相异，商为负值
**详细解释：** 有符号除法复杂的原因在余数部分的符号，解决方法：让被除数和余数符号保持一致，通过商和除数的符号进行匹配。

#### 3.2.3.3 快速除法
区别于快速乘法：每一步运算需要上一步的符号结果
**SRT 除法技术**：预测每步多个商的位数，依靠后续步骤纠正错误预测

#### 3.2.3.4 RISC-V 中的除法
1. **除法指令 (div)**：用于有符号整数的除法。
2. **无符号除法指令 (divu)**：用于无符号整数的除法。
3. **余数指令 (rem)**：用于有符号整数的取余。
4. **无符号余数指令 (remu)**：用于无符号整数的取余

### [[../../Contents/第三章 计算机的算术运算|回到目录]]