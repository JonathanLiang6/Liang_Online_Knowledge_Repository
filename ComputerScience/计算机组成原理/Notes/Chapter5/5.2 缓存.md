### 5.2.1 缓存基础
缓存，在内存层次中最靠近 CPU
#### 5.2.1.1 映射
**直接映射的缓存**：根据内存地址，直接确定缓存位置
直接映射：唯一映射 ![[../../Picture/Pasted image 20241210212448.png]]
#### 5.2.1.2 标签&有效位
**多对一映射**中如何确定哪个内存块存放在缓存中：
缓存中存放**数据**的同时，存放**块地址**
只需要存放块地址的**高位部分**：称为**标签**
判断对应缓存块中是否存放有效数据：使用**有效位**：1有效；0无效
有效位初始化值为 0
#### 5.2.1.3 缓存举例
![[../../Picture/Pasted image 20241211000654.png]] 地址划分
![[../../Picture/Pasted image 20241211000820.png]]
#### 5.2.1.4 缓存块相关
更大的缓存块可以提升命中率，提升了空间局部性 
**固定缓存总容量**要面临以下问题： 
更大缓存块$\Rightarrow$更少的缓存块数目 (缓存容量 = 缓存块大小 $\times$ 缓存块数目) 
更大的缓存块$\Rightarrow$更容易被污染（写回成本高）
更多的缓存块竞争$\Rightarrow$降低命中率$\Rightarrow$不能充分利用时间局部性 
更大的未命中惩罚：加载大的缓存块需要更长时间 
**未命中问题**：
缓存命中时，CPU 正常执行
缓存未命中: 处理方法类似可恢复的异常处理：
停顿 CPU 流水线，然后从下一级缓存加载对应的缓存块：更新当前级缓存 
	指令缓存未命中：重新从当前级缓存读取指令 
	数据缓存未命中：重新在当前级缓存完成数据操作
#### 5.2.1.5 缓存的写操作
##### 策略 1：写直达
在数据写命中时，直接更新缓存中对应的块：但是缓存和下一级内存的内容会不一致
**写直达**策略: 同时更新下级存储，但是写操作需要更长时间
`e.g 比如，假设基础CPI为1，10%的指令为store指令，写入主存需要100个周期实际的CPI = 1 + 0.1×100 = 11` 
**加速写直达**: 写缓冲区 
保存等待写到主存的数据，CPU 立即往后执行
只有写缓存区满了，才会阻塞store指令利用写缓冲区加速写直达策略
##### 策略 2: 写回 
**写回**策略：在数据写命中时，只更新缓存中的块。记录每个缓存块是否被写过
后面当一个脏块被替换时（write+read） 将该块的旧内容写回到主存（write），同时从主存加载新的内存块到缓存
可以利用一个写缓冲区，这样写操作不会阻塞，可以立即开始 read 操作（）利用写缓冲区加速写回策略
##### 写未命中问题
写操作未命中时
**写分配**：+写回策略：立即从下级存储加载缓存块 
**写不分配**：+写直达策略：直接在内存中写，不加载缓存块
因为程序有时写完一个内存块之后很久，才去读这个内存块（比如，初始化数据），因此没必要写失效时就加载到缓存
![[../../Picture/Pasted image 20241211092147.png]]
![[../../Picture/Pasted image 20241211092203.png]]
**写缓冲区**可以隐藏内存写操作
通过**预取**可以隐藏内存读操作
#### 5.2.1.6 Cache 举例 
> Chapter 5 — Large and Fast: Exploiting Memory Hierarchy — 53 例子: Intrinsity FastMATH
[[Files/Chapter05/Chapter_05-1 memory hierarchy & cache简化版.pdf#page=53&selection=0,9,11,21|Chapter_05-1 memory hierarchy & cache简化版, 页面 53]]
书 P288
### 5.2.2 缓存的性能
#### 5.2.2.1 测量缓存的性能
**[[../Chapter1/1.2 性能相关问题#1.2.5 指令性能|CPU时间]]** 的组成 = 程序执行所需的时钟 + 内存阻塞所需的时钟
**程序执行所需的时钟**包括缓存命中的时间：见第一章 [[../Chapter1/1.2 性能相关问题#^3355d0|CPU时间]]
**内存阻塞所需的时钟**主要源自缓存失效
简化的假设：
$\text{程序的内存阻塞周期数}$
$=\text{程序的内存访问次数}\times \text{失效率} \times \text{失效惩罚}$
$= \text{程序的指令数目} \times \frac{失效数}{指令数目} \times \text{失效惩罚}$
`e.g 举例如下`
![[../../Picture/Pasted image 20241211145357.png]]
#### 5.2.2.2 平均内存访问时间
**命中时间对性能也很重要**
平均内存访问时间 (AMAT) 
AMAT = 命中时间 + 失效率 $\times$ 失效惩罚 
`e.g 假设 CPU 时钟为 1ns，命中时间为 1 个时钟，缓存失效率为 5%CPU，失效惩罚为 20 个时钟 AMAT = 1 + 0.05 × 20 = 2ns  CPI = 2` 
#### 5.2.2.3 性能小结
##### 缓存性能简介
当 CPU 性能提升时，失效惩罚 * 失效率带来的性能下降，会更突出 
因此，在评估系统性能时，不能忽视缓存 
**解决方法**：降低失效惩罚/降低失效率
##### **性能优化方法**：
**硬件优化** 
利用**相联度**降低**失效率** 
利用**多级缓存**降低**失效惩罚** 
通过**小容量** L1 缓存减少**命中时间** 
**缓存块大小**的考虑：失效率↓，失效惩罚↑ 
**软件优化**： 
分块、重排、分块 & 重排 
### 5.2.3 相联缓存
#### 5.2.3.1 相联缓存简介
直接映射：内存块号直接映射到唯一缓存块 
**全相联** 
	允许内存块映射到任意缓存块
	查找时，需要同时搜索所有缓存块 
	所有缓存块都需要配备一个比较器（很昂贵） 
**k 路-组相联** 
	允许内存块映射到**一个组内**的任意缓存块（每组 k 个） 
	内存块直接映射到唯一缓存组（组中的任意块） (内存块号) mod(缓存中的组数) 
	查找时，需要同时搜索**一个组内**的所有缓存块 
	使用k个比较器 (没那么昂贵)
#### 5.2.3.2 组相联缓存的例子
![[../../Picture/Pasted image 20241211224330.png]]
在不同的映射方式下，内存块存放在不同的缓存块中。例如，内存地址的块号为 12，根据不同的相联度，12 可以映射到不同的缓存块中：
- 对于直接映射，12 mod 8 = 4，因此映射到缓存块 4。
- 对于 2 路组相联，12 mod 4 = 0，因此映射到第 0 组的任意块。
- 对于全相联，12 可以映射到任何一个缓存块。

#### 5.2.3.3 相联度
计算缓存有 8 个缓存块，不同的相联度选择会影响缓存的性能和成本。
**相联度的例子**
假设缓存有 4 个块，比较直接映射、2 路组相联和全相联在访问序列 0, 8, 0, 6, 8 时的表现：
- **直接映射** (0%4, 8%4, 0%4, 6%4, 8%4)
直接映射会导致多次失效，因为每个内存块号只能映射到一个特定的缓存块。

| 内存块号 | 缓存块号 | 命中/失效 | 缓存块 0  | 缓存块 1 | 缓存块 2  | 缓存块 3 |
| ---- | ---- | ----- | ------ | ----- | ------ | ----- |
| 0    | 0    | 失效    | Mem[0] |       |        |       |
| 8    | 0    | 失效    | Mem[8] |       |        |       |
| 0    | 0    | 失效    | Mem[0] |       |        |       |
| 6    | 2    | 失效    | Mem[0] |       | Mem[6] |       |
| 8    | 0    | 失效    | Mem[8] |       | Mem[6] |       |

- **2路组相联** (0%2, 8%2, 0%2, 6%2, 8%2)
2 路组相联减少了失效次数，因为每个内存块号可以映射到组内的任意块

| 内存块号 | 缓存块号 | 命中/失效 | 缓存组 0  | 缓存组 0  | 缓存组 1 | 缓存组 1 |
| ---- | ---- | ----- | ------ | ------ | ----- | ----- |
| 0    | 0    | 失效    | Mem[0] |        |       |       |
| 8    | 0    | 失效    | Mem[0] | Mem[8] |       |       |
| 0    | 0    | 命中    | Mem[0] | Mem[8] |       |       |
| 6    | 0    | 失效    | Mem[0] | Mem[6] |       |       |
| 8    | 0    | 失效    | Mem[8] | Mem[6] |       |       |

- **全相联**
全相联在这种情况下表现最佳，因为它允许内存块号映射到任何一个缓存块，从而最大化地减少了失效次数。

| 内存块号 | 命中/失效 | 缓存的内容  | 缓存的内容  | 缓存的内容  | 缓存的内容 |
| ---- | ----- | ------ | ------ | ------ | ----- |
| 0    | 失效    | Mem[0] |        |        |       |
| 8    | 失效    | Mem[0] | Mem[8] |        |       |
| 0    | 命中    | Mem[0] | Mem[8] |        |       |
| 6    | 失效    | Mem[0] | Mem[8] | Mem[6] |       |
| 8    | 命中    | Mem[0] | Mem[8] | Mem[6] |       |
**相联度的影响**
相联度越高，失效率越低，但是效益递减，并且需要更多的比较器。
模拟实验表明，对于 64KB 的数据缓存，每块有 16 个字，应用程序 SPEC2000 的失效率随着相联度的增加而降低，但递减效应明显。

#### 5.2.3.4 组相联缓存的构成
![[../../Picture/Pasted image 20241211230733.png]]
组相联缓存由 k 个比较器构成，这些比较器用于在组内查找内存块。

#### 5.2.3.5 替换策略
**直接映射**：无法替换，只有唯一选择
**组相联缓存**，当需要替换缓存块时，可以采用以下策略：
- 优先空闲缓存块（有效位为 0 的块）。
- 其次，在组内挑选一个缓存块：
- **近期最少使用**（LRU）策略：选择最长时间内未被使用的缓存块
	- 实现难度：2 路简单，4 路可控，超过 4 路很难
- **随机**策略：对于高度相联缓存，其性能接近 LRU
### 5.2.4 多级缓存
#### 5.2.4.1 多级缓存
多级缓存包括：
**附属在 CPU 的主缓存（L1 缓存）**：容量小，速度快
**L2 缓存**：L1 缓存失效时，从 L2 缓存供应
**主存**：L2 缓存失效时，从主存供应。有些高端系统，在主存之上还有 L3 缓存。
`e.g 通过计算只有主缓存，增加L2缓存的情况，可推得多级缓存可以增加速度`
#### 5.2.4.2 多级缓存的影响
L1 缓存：关注最小的命中时间 
L2 缓存：关注降低失效率以避免主存访问，命中时间影响不大
因此 L1 缓存的容量通常较小，块大小也比 L2 缓存的块大小要小。
### 5.2.5 缓存其他知识
#### 5.2.5.1 缓存对高级 CPU 中的影响
乱序执行的 CPU 在发生缓存失效时，可以执行其他指令
而被阻塞的 load/store 指令则需要等待漫长的内存访问
依赖 load/store 指令的指令只能等待 $\Leftrightarrow$ 无关 load/store 指令的指令可以继续执行
失效时的行为依赖于程序的数据流：很难静态分析，通常用系统仿真
#### 5.2.5.2 缓存对软件的影响
内存访问模式会引起失效，影响算法和编译优化，程序员可以通过编写利用缓存局部性的代码来提升性能。
![[../../Picture/Pasted image 20241212170006.png]]
#### 5.2.5.3 局部性的量化估计
通过分析代码，可以量化估计局部性，例如，通过分析数组访问模式和缓存块大小来计算命中率。
`e.g1 假设块大小为32字节，命中率为7/8`
```c
int sum_array_rows(int a[M][N]) { 
	int i, j, sum = 0; 
	for (i = 0; i < M; i++) 
		for (j = 0; j < N; j++) 
			sum += a[i][j]; 
	return sum; 
}
```
**缓存块利用情况**：
	- `int` 类型占4字节：因此每个缓存块可以存储 $\frac{32}{4}=8$个整型元素。
    - 每次加载一个缓存块时，包含8个连续的数组元素（例如 `a[i][0]` 到 `a[i][7]`）。
    - 之后对 `a[i][1]` 到 `a[i][7]` 的访问都在这个缓存块中，属于**缓存命中**
    - 当访问到 `a[i][8]` 时，需要加载新的缓存块，触发一次缓存缺失（miss）
每次访问一块缓存块时，只有第一个元素是缓存缺失，剩下的7个元素命中。
按照 **行优先** 访问的内存访问模式充分利用了缓存块中的连续性。
`e.g2 假设同上`
```C
int sum_array_rows(int a[M][N]) { 
	int i, j, sum = 0; 
	for (j = 0; j < N; j++) 
		for (i = 0; i < M; i++)
			sum += a[i][j]; 
	return sum; 
}
```
每个缓存块只有第一个访问是命中，其余7次都不命中
#### 5.2.5.4 软件优化的小结
缓存对性能有显著影响，程序员可以通过优化代码来提升性能，例如通过循环重排和缓存分块（cache blocking）来最大化空间局部性和时间局部性。
### [[../../Contents/第五章 多层次存储|回到目录]]

