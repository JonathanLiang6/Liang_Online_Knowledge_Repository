### 4.2.1 控制单元介绍
**ALU** 的控制：选择一种运算
**选择器**的控制：选择一个输入
**状态逻辑**的 r/w 控制: 使能状态逻辑 
- 寄存器的**写**使能（enable）信号 
- 内存的**读/写**使能信号
下面介绍一种简化版的实现方案，该方案支持指令：load（ld），store（sd），分支指令（beq），算术逻辑指令（add、sub、and、or）
### 4.2.2 ALU 的控制
#### 4.2.2.1 初步介绍
![[../../Picture/Pasted image 20241128083444.png]]
**多级译码：** 主控制单元 (产生 ALUOp) 和 ALU 控制单元
降低主控制单元的大小，也可能降低**控制单元的延迟**，控制单元的延迟是决定时钟周期的关键因素
#### 4.2.2.2 操作码控制 
从操作码生成 2 个 bit 的 ALUOp 型号
基于 ALUOp，指令中的 Funct7(31-25) 和 Funct3(14-12) 构造组合逻辑，生成 4 个 bit 的
ALU 控制型号，决定 ALU 的功能
（只有 R 型指令的 Funct7 和 Funct3 影响 ALU 控制型号）
（ld/sd 的输入输出完全一样，本质都是 add：寄存器+立即数）

|        | 输入    |          | 输入      | 输入     |          | 输出      |
| ------ | ----- | -------- | ------- | ------ | -------- | ------- |
| opcode | ALUOp | 操作       | Funct7  | Funct3 | ALU 功能   | ALU控制信号 |
| ld     | 00    | load     | XXXXXXX | XXX    | add      | 0010    |
| sd     | 00    | store    | XXXXXXX | XXX    | add      | 0010    |
| beq    | 01    | 分支指令     | XXXXXXX | XXX    | subtract | 0110    |
| R-type | 10    | add      | 0000000 | 000    | add      | 0010    |
| R-type | 10    | subtract | 0100000 | 000    | subtract | 0110    |
| R-type | 10    | AND      | 0000000 | 111    | AND      | 0000    |
| R-type | 10    | OR       | 0000000 | 110    | OR       | 0001    |
ALU 控制单元的优化：![[../../Picture/Pasted image 20241128091428.png]]
### 4.2.3 控制线
带控制线的数据通路：控制线的值只取决于操作码（6 位）[[#4.2.2.1 初步介绍|6位的位置参见此图]]
![[../../Picture/Pasted image 20241128092033.png]]

#### 4.2.3.1 六种控制型号的功能

| 信号名      | 无效时的效果（置0）                               | 有效时的效果（置1）                                       |
| -------- | ---------------------------------------- | ------------------------------------------------ |
| RegWrite | 无                                        | 被写的寄存器号来自Write register信号的输入，数据来自Write data信号的输入 |
| ALUSrc   | 第二个ALU操作数来自第二个寄存器堆的输出（即Read data 2信号的输出） | 第二个ALU操作数是指令的低12位符号扩展                            |
| PCSrc    | PC值被adder的输出所替换，即PC+4的值                  | PC值被adder的输出所替换，即分支目标                            |
| MemRead  | 无                                        | 读地址由Address信号的输入指定，输出到Read data信号的输出中            |
| MemWrite | 无                                        | 写地址由Address信号的输入指定，写入内容是Write data信号的输入中的值       |
| MemtoReg | 寄存器写数据的输入值来自ALU                          | 寄存器写数据的输入值来自数据存储器                                |
#### 4.2.3.2 控制线的值
控制线的值只取决于操作码，下表中 X 表示

| 指令格式 | ALU 源选择 | 存储器到寄存器 | 寄存器写入 | 存储器读取 | 存储器写入 | 分支  | ALU 操作 1 | ALU 操作 0 |
| ---- | ------- | ------- | ----- | ----- | ----- | --- | -------- | -------- |
| R 格式 | 0       | 0       | 1     | 0     | 0     | 0   | 1        | 0        |
| ld   | 1       | 1       | 1     | 1     | 0     | 0   | 0        | 0        |
| sd   | 1       | X       | 0     | 0     | 1     | 0   | 0        | 0        |
| beq  | 0       | X       | 0     | 0     | 0     | 1   | 0        | 1        |
#### 4.2.3.3 控制函数的真值表
| 输入或输出 | 信号名称     | R格式 | ld  | sd  | beq |
| ----- | -------- | --- | --- | --- | --- |
| 输入    | I[6]     | 0   | 0   | 0   | 1   |
| 输入    | I[5]     | 1   | 0   | 1   | 1   |
| 输入    | I[4]     | 1   | 0   | 0   | 0   |
| 输入    | I[3]     | 0   | 0   | 0   | 0   |
| 输入    | I[2]     | 0   | 0   | 0   | 0   |
| 输入    | I[1]     | 1   | 1   | 1   | 1   |
| 输入    | I[0]     | 1   | 1   | 1   | 1   |
| 输出    | ALUSrc   | 0   | 1   | 1   | 0   |
| 输出    | MemtoReg | 0   | 1   | X   | X   |
| 输出    | RegWrite | 1   | 1   | 0   | 0   |
| 输出    | MemRead  | 0   | 1   | 0   | 0   |
| 输出    | MemWrite | 0   | 0   | 1   | 0   |
| 输出    | Branch   | 0   | 0   | 0   | 1   |
| 输出    | ALUOp1   | 1   | 0   | 0   | 0   |
| 输出    | ALUOp0   | 0   | 0   | 0   | 1   |
#### 4.2.3.4 各种指令使用的数据通路及控制信号
![[../../Picture/Pasted image 20241130160912.png]]
![[../../Picture/Pasted image 20241130161441.png]]
![[../../Picture/Pasted image 20241130161538.png]]
上述为三种指令对应的数据通路及控制信号
### [[../../Contents/第四章 处理器|回到目录]]