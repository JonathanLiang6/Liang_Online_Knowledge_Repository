### 4.1.1 [[4.0 前置知识：CPU组件#4.0.4 CPU 组件|CPU组件]]
### 4.1.2 数据通路
**数据通路：** CPU 中用来处理数据和地址的逻辑的集合
#### 4.1.2.1 执行指令的操作
1. 从 **指令存储器（其中的IMEM）** 中取出指令
2. 指令提供寄存器编号：从[[4.0 前置知识：CPU组件#4.0.3.2 寄存器文件|寄存器文件]] 读取指定寄存器
3. 根据指令提供的操作码进行操作
ALU 计算可得到：①算术运算的结果；②load/store 指令需要访问的内存地址；③分支比较的结果
load/store 指令读/写访问 DMEM
对于 load 指令和 R 型指令，将结果更新到目的寄存器
4. 更新 PC：指向下一条指令（向后移动 4 个字节）或分支指令的目标地址
#### 4.1.2.2 取指令
![[../../Picture/Pasted image 20241126145223.png]]
1. 从 IMem 中读取指令
2. 更新 PC ：修改成下一条（顺序）指令的地址读访问指令 
每个时钟都会更新 PC 寄存器, 因此 PC 寄存器不需要写控制信号, 只需要时钟信号 
从 IMem 读取指令是组合逻辑行为（不需要更新状态）, 因此不需要读控制信号
#### 4.1.2.3 解码
![[../../Picture/Pasted image 20241126145324.png]]
1. **解码**：理解指令的含义 
2. 将指令的操作码、功能字段的值，发送到控制单元
#### 4.1.2.4 读取寄存器
对所有指令，解码时寄存器文件的两个读端口均是活跃的(使用 rs1 和 rs2 指定寄存器)
此时指令解码没有完成，CPU 无法分辨指令的类别
提前读取两个寄存器以防万一该指令需要这两个寄存器中的值
### 4.1.3 常规类型指令数据通路
#### 4.1.3.1 [[../Chapter2/2.3 计算机指令#2.3.2.1 R 型（用于寄存器）指令|R 型指令]]
| funct7  | rs2 | rs1 | funct3 | rd  | opcode  |
| ------- | --- | --- | ------ | --- | ------- |
| 0000000 | rs2 | rs1 | 000    | rd  | 0110011 |
读两个寄存器 $\Rightarrow$ 进行算术逻辑运算 $\Rightarrow$ 写寄存器的结果
实现 add 指令：add	rd, rs1, rs2
![[../../Picture/Pasted image 20241126152302.png]]
#### 4.1.3.2 [[../Chapter2/2.3 计算机指令#2.3.2.2 I 型（用于带常数）指令|I型指令]]
| imm[11:0]    | rs1   | funct3 | rd   | opcode  |
| ------------ | ----- | ------ | ---- | ------- |
| 111111001110 | 00001 | 000    | 0111 | 0010011 |
 实现 addi 指令：addi x15, x1, -50
![[../../Picture/Pasted image 20241127144300.png]]
**I 型指令中的 immediate**
![[../../Picture/Pasted image 20241126161404.png]] 指令的高 12 位 (inst[31:20]) 拷贝到 immediate 的低 12 位 (imm[11:0])  
符号扩展：将符号位 inst[31]填充到 immediate 的高 52 位 (imm[63:12])
其他 I 型指令只需要修改 ALU 的选择信号 op 即可
#### 4.1.3.3 load/store 指令 (I 型/S 型)
利用 rs1 和 12 位偏移计算地址：先对偏移 imm 进行符号扩展再使用 ALU
load：读内存，更新寄存器
store：将寄存器写入内存
执行 load 指令：                                                 执行 store 指令：![[../../Picture/Pasted image 20241126161054.png]]
![[../../Picture/Pasted image 20241127144408.png]]
#### 4.1.3.4 集成结果 
![[../../Picture/Pasted image 20241127144534.png]]
简化版的数据通路，在一个时钟周期内完成**一条指令** 
单个时钟内，每个通路逻辑的只完成一个功能 ：
数据流上没有回边；需要分开的 IMem 和 DMem 
当多条指令导致多个数据来源时，需要引入**选择器**
### 4.1.4 其他指令数据通路
#### 4.1.4.1 分支指令
B 型指令机会跟 S 型指令一样, 都有两个来源寄存器 (rs1/rs2) 和一个 12-bit 立即数 
对两个操作数进行比较运算：使用 ALU, 先减法运算，再检测 Zero 输出 
立即数表示范围： [-4096,+4094] （步长为 2 字节） 
计算目标地址：先对立即数进行有符号扩展，然后立即数左移 1 位 (恢复成单字节寻址)，最后跟 PC 值相加 ![[../../Picture/Pasted image 20241127153148.png]]
#### 4.1.4.2 JAL 指令/JALR 指令（I 型）
![[../../Picture/Pasted image 20241127162236.png]]
**JAL：**
JAL 将 PC+4 保存到 rd 寄存器 (返回地址) 将 PC 更新为：PC + offset (PC-相对跳转) 
跳转目标的范围为：当前地址 $±2^{19}$ 个 2字节地址 $\Rightarrow$ $±2^{18}$ 条 32 位宽的指令 
跟分支指令 beg 类似，立即数的编码节省了一个 bit 位
**JALR：**
将 PC+4 保存到 rd 寄存器 (返回地址) （如果 rd 不是 x0 时） 
将 PC 更新为： rs1 寄存器的值 + immediate 
跟算术指令、load 指令指令类似：立即数参与运算时不需要乘以 2（跟分支指令不同）
#### 总结
单周期 RISC-V RV64I 数据通路：
可以从 Reg 更新 PC (间接跳转）——PC 寄存器第 3 个来源 
PC+4 可以被保存到一个寄存器——寄存器文件第 3 个来源 ![[../../Picture/Pasted image 20241128081823.png]]
统一的数据通路 
• 能够在一个周期内完成任意一条 RISC-V 指令 
• 每条指令只会用到通路中的特定的部分 
指令的执行包括 5 个阶段 ：IF, ID, EX, MEM, WB 
• 大部分指令不会在 5 个阶段都活跃 
控制器来规定指令的执行
### [[../../Contents/第四章 处理器|回到目录]]